<!DOCTYPE html>
<html>
<head>
  <title>Mastering Node</title>
  <meta name="description" content="Mastering Node" />
  <meta name="keywords" content="node.js,node,Mastering Node,JavaScript" />
  <meta name="author" content="TJ Holowaychuk, et al." />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <link rel="stylesheet" href="assets/style.css" type="text/css" media="all" />
  <link rel="stylesheet" href="assets/sh.css" type="text/css" media="all"/>
</head>
<body>
  <div id="container"> 
<div style="display:none"><!-- all --></div>
<h1>Mastering Node</h1>

<p><a href="http://nodejs.org">Node</a> is an exciting new platform developed by <em>Ryan Dahl</em>, allowing JavaScript developers to create extremely high performance servers by leveraging <a href="http://code.google.com/p/v8/">Google V8</a> JavaScript engine, and asynchronous I/O. In <em>Mastering Node</em>) we will discover how to write high concurrency web servers, utilizing the CommonJS module system, node's core libraries, third party modules, high level web development and more.</p>

<h2 id="why_Node_">Why Node?</h2>

<p>Node is an evented I/O framework for server-side JavaScript.  What does that mean, though?  In many programming languages, I/O operations are blocking.  This means that when you open a file, no other code executes until that file is fully opened.  </p>

<p>Using a busy office environment as an example, blocking I/O operations are like a very busy and very focussed desk worker name Frank. Work may pile up on the desk, but Frank finishes every task that he starts (however, when he finds the smallest problem, he gives up).  This is traditionally how procedural programming languages perform tasks.</p>

<p>Node.js is more like an office manager. Sure, there are management tasks, but all of those I/O operations are handled fairly well by the operating system or node addons.  So, the manager sees a task, assigns it to Frank.  The manager may check back on Frank from time to time to see how he's doing, but he doesn't need to waste his time on the task because he knows that when it's completed, Frank will give it back.</p>

<p>Don't worry, though.  Node.js isn't a jerk, so look forward to a healthy relationship.</p>

<h2 id="why_JavaScript_">Why JavaScript?</h2>

<p><strong>JavaScript is a well-known dynamic language.</strong></p>

<p>In fact, many people who don't consider themselves programmers know JavaScript. Node.js uses <a href="http://code.google.com/apis/v8/intro.html">Google's V8 JavaScript engine</a>.  V8 is an implementation of the JavaScript standards specified in <a href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">ECMA-262, Version 3</a>. It is a high-performance, garbage-collected execution environment which can be embedded in any stand-alone application.</p>

<p><strong>Everything in JavaScript is an <code>Object</code>.</strong></p>

<p>Arrays are <code>Objects</code>.  Object literals are <code>Object</code>s.  Even functions are <code>Object</code>s.</p>

<p><strong>JavaScript supports some fairly advanced functional programming concepts. <a href="http://www.ibm.com/developerworks/library/wa-javascript.html#functional">?</a></strong></p>

<p>Currying, closures, functions-as-arguments, and anonymous functions are concepts typically found in functional programming languages.  There are libraries available, such as <a href="http://documentcloud.github.com/underscore/">underscore.js</a>, which provider more functional programming functionality without changing JavaScript itself.</p>

<p><strong>It's awesome. I had to say it.</strong></p>

<p>For a deep understanding of what JavaScript really has to offer, check out <a href="http://oreilly.com/catalog/9780596806767">JavaScript Patterns</a>.</p>

<h2 id="hello_World_">Hello World!</h2>

<p><strong>Becuase it has to be done</strong></p>

<pre><code>// hello.js
sys = require('sys');
sys.puts("Hello, World!");</code></pre>

<p>To run the 'Hello, World!' example, execute <code>node hello.js</code> on the command line.</p>

<h2 id="conventions_in_this_book">Conventions in this book</h2>

<p><strong>Code Blocks</strong></p>

<p>There are a few conventions used in the code example blocks (such as the Hello, World! example above).</p>

<p>First, if the example is a script (or a part of a script) that needs to be run from the command line, it will begin with a <code>//</code> styled comment of the filename.  These files are located under the <code>./src</code> directory of the <em>Mastering Node</em> project.  Running these examples is fairly simple: open a terminal (CTRL+SHIFT+T might do it) and type <code>node</code> followed by a space and the relative path of the script.  In other words, if you're in <em>/home/jim/masteringnode</em> and you want to run a script under <em>/home/jim/masteringnode/scripts/</em> which is called <em>hello.js</em>, you would run <code>node scripts/hello.js</code> or <code>node ./scripts/hello.js</code>.  For an example of how this code snippet is displayed, see the Hello, World! example above.</p>

<p>Second, if the example is a command to be entered directly into what will be referred to as a 'node terminal', you should first open a terminal then type <code>node</code> and ENTER (assuming the node executable is in your PATH variable, and is called node).  At the prompt, you should enter the commands following the <code>&gt;</code> character. Text following the <code>&gt;</code> character are commands you should enter, while text on a line that does not begin with <code>&gt;</code> is the output.  This is done to closely match what you should see in your terminal.  These examples are not included in files under the <em>src</em> directory.  For instance:</p>

<pre><code>&gt; console.log("Hello, World!")
Hello, World.</code></pre>

<p>Third, if an example is to be run from the terminal itself, it is prefixed by a <code>$</code>.  This represents a bash environment, and may look differently depending on your configuration.  For instance, my bash terminal displays:</p>

<pre><code>jim@cr-48:~/projects/masteringnode$</code></pre>

<p>These code examples will look like this:</p>

<pre><code>$ ruby -e "puts 'Hello, World'"</code></pre>

<p>Finally, code without a prefix is a sample of a possible solution or expected output from <em>stdout</em>.  This is not necessarily code you should type into your terminal or run as a script, unless of course you want to experiment.  For example, suppose we're discussing CommonJS and we'd like to show how something <em>would</em> be done in CommonJS, we might show an example such as:</p>

<pre><code>var utils = {};
utils.merge = function(obj, other) {};</code></pre>

<p>This wouldn't contain a filename unless there is a working example (in which case, it's a concrete example and no longer hypothetical).</p>

<p><strong>Inline Code</strong></p>

<p>Occasionally, there will be code or commands that are being explained and displayed inline to separate them visually from the rest of the sentence.  For instance, if we were talking about how to include modules into your code, we may say to add a <code>var fs = require('fs');</code> line to the top of your file.  Code displayed like this is generally accompanied by an explanation of the code itself or instructions for where to add the code.  </p>

<p>Functions may be displayed as <code>require()</code> or <code>require</code>, depending on the context for readability. That is, when we're talking about any JavaScript objects, we'll most likely use <code>require</code> since a function is also an object.  </p>

<p>If we're talking about multiple functions, we may say "use the functions: <code>doSomething1</code> and <code>doSomething2</code>" instead of "use the functions: <code>doSomething1()</code> and <code>doSomething2()</code>" because the parentheses can be implied and the absence of parentheses is easier on the eyes.</p>

<p><strong>Files and Directories</strong></p>

<p>Files and directories will be displayed in italics when inline, or as a relative path to the <em>Mastering Node</em> source directory in code comments when in a code example block.  For instance, if we reference <em>/home/jim/masteringnode/src/modules/fake.js</em> in a code example, it will look like:</p>

<pre><code>// modules/fake.js
var num = 1;</code></pre>

<h1>Installing Node</h1>

<p>In this chapter we will be looking at the installation and compilation of node. Although there are several ways we may install node, we will be looking at <a href="http://github.com/mxcl/homebrew">homebrew</a>, and the most flexible method, of course - compiling from source.</p>

<h3 id="homebrew">Homebrew</h3>

<p>Homebrew is a package management system for <em>OSX</em> written in Ruby, is extremely well adopted, and easy to use.  Homebrew can be installed in a number of ways.  Possibly the easiest way is to perform a quick install to <code>/usr/local/</code>:</p>

<pre><code>$ ruby -e "$(curl -fsSL https://gist.github.com/raw/323731/install_homebrew.rb)"</code></pre>

<p>Next, to install node via the <code>brew</code> executable, simply run:</p>

<pre><code>$ brew install node.js</code></pre>

<p>For more information on packages and commands available to homebrew, checkout the README at github.</p>

<h2 id="building_From_Source">Building From Source</h2>

<p>To build and install node from source, we first need to obtain the code. The first method of doing so is
via <code>git</code>, if you have git installed you can execute:</p>

<pre><code>$ git clone http://github.com/joyent/node.git &amp;&amp; cd node</code></pre>

<p>For those without <em>git</em>, or who prefer not to use it, we can also download the source via <em>curl</em>, <em>wget</em>, or similar:</p>

<pre><code>$ curl -# http://nodejs.org/dist/node-v0.4.2.tar.gz &gt; node.tar.gz
$ tar -zxf node.tar.gz</code></pre>

<p>Now that we have the source on our machine, we can run <code>./configure</code> which discovers which libraries are available for node to utilize such as <em>OpenSSL</em> for transport security support, C and C++ compilers, etc. <code>make</code> which builds node, and finally <code>make install</code> which will install node.</p>

<pre><code>$ ./configure &amp;&amp; make &amp;&amp; sudo make install</code></pre>

<h2 id="installing_from_Distribution_Sources">Installing from Distribution Sources</h2>

<p>Installing node.js from a distribution's repositories is not highly recommended.  This is because the version included with your distribution may be very outdated.  As an example, the original version of this document was written to target node.js 0.1.99.  In Ubuntu 10.10, the version of node.js included in the official repository is 0.1.97-1build1.  Because node.js is a relatively young project with a large community, changes to the API occur quickly and often.</p>

<p>If you still wish to install nodejs from an official repository, it can be done in the usual way:</p>

<pre><code>$ sudo apt-get install nodejs
$ yum install nodejs</code></pre>

<p>Refer to your distribution's documention or wiki for the proper commannd for installation from the official repository.</p>

<h3 id="npm_Node_Package_Manager">npm: Node Package Manager</h3>

<p>npm is a node package manager with a relatively large category of available modules.  To install directly in one line, run:</p>

<pre><code>$ curl http://npmjs.org/install.sh | sh</code></pre>

<p>If this one-liner fails, run:</p>

<pre><code>$ git clone http://github.com/isaacs/npm.git
$ cd npm
$ sudo make install</code></pre>

<p>For more information on npm, check out the <a href="https://github.com/isaacs/npm">repo</a>.</p>

<h2 id="installing_other_packages">Installing other packages</h2>

<p>Using npm, we'll install other packages needed for the examples in this book.</p>

<pre><code>$ sudo npm install connect express nodeunit geddy zombie</code></pre>

<p>Let npm do it's thing.  It will install these modules any any dependencies.  You'll see output similar to the following:</p>

<pre><code>npm info activate jsdom@0.1.23
npm info postactivate jsdom@0.1.23
npm info build Success: express@1.0.7
npm info build Success: nodeunit@0.5.1
npm info build Success: mime@1.2.1
npm info build Success: geddy@0.1.3
npm info build Success: websocket-client@1.0.0
npm info build Success: connect@1.0.1</code></pre>

<h1>CommonJS Module System</h1>

<p><a href="http://commonjs.org">CommonJS</a> is a community driven effort to standardize packaging of JavaScript libraries, known as <em>modules</em>. Modules written which comply to this standard provide portability between other compliant frameworks such as narwhal, and in some cases even browsers. </p>

<p>Although this is ideal, in practice modules are often not portable due to relying on apis that are currently only provided by, or are tailored to node specifically. As the framework matures, and additional standards emerge our modules will become more portable.  </p>

<h2 id="creating_Modules">Creating Modules</h2>

<p>Let's create a utility module named <em>utils</em>, which will contain a <code>merge()</code> function to copy the properties of one object to another. Typically in a browser, or environment without CommonJS module support, this may look similar to below, where <code>utils</code> is a global variable. </p>

<pre><code>var utils = {};
utils.merge = function(obj, other) {};</code></pre>

<p>Although namespacing can lower the chance of collisions, it can still become an issue, and when further namespacing is applied it can look flat-out silly. CommonJS modules aid in removing this issue by "wrapping" the contents of a JavaScript file with a closure similar to what is shown below, however more pseudo globals are available to the module in addition to <code>exports</code>, <code>require</code>, and <code>module</code>. The <code>exports</code> object is then returned when a user invokes <code>require('utils')</code>.</p>

<pre><code>var module = { exports: {}};
  (function(module, exports){
      function merge(){};
      exports.merge = merge;
  })(module, module.exports);</code></pre>

<p>First create the file <em>./modules/utils.js</em>, and define the <code>merge()</code> function as seen below. The implied anonymous wrapper function shown above allows us to seemingly define globals, however these are not accessible until exported. </p>

<pre><code>function merge(obj, other) {
  var keys = Object.keys(other);
  for (var i = 0, len = keys.length; i &lt; len; ++i) {
    var key = keys[i];
    obj[key] = other[key];
  }
  return obj;
};

exports.merge = merge;</code></pre>

<p>The typical pattern for public properties is to simply define them on the <code>exports</code> object like so:</p>

<pre><code>// modules/utils.js
exports.merge = function(obj, other) {
  var keys = Object.keys(other);
  for (var i = 0, len = keys.length; i &lt; len; ++i) {
      var key = keys[i];
      obj[key] = other[key];
  }
  return obj;
};</code></pre>

<p>Next we will look at utilizing out new module in other libraries.</p>

<h2 id="requiring_Modules">Requiring Modules</h2>

<p>To get started with requiring modules, first create a second file named <em>./modules/app.js</em> with the code shown below. The first line <code>require('./utils')</code> fetches the contents of <em>./modules/utils.js</em> and returns the <code>exports</code> of which we later utilize our <code>merge()</code> method and display the results of our merged object using <code>console.dir()</code>.</p>

<pre><code>// modules/app.js
var utils = require('./utils');

var a = { one: 1 };
var b = { two: 2 };
utils.merge(a, b);
console.dir(a);</code></pre>

<p>Core modules such as the <em>sys</em> which are bundled with node can be required without a path, such as <code>require('sys')</code>, however 3rd-party modules will iterate the <code>require.paths</code> array in search of a module matching the given path. By default <code>require.paths</code> includes <em>~/.node_libraries</em>, so if <em>~/.node_libraries/utils.js</em> exists we may simply <code>require('utils')</code>, instead of our relative example <code>require('./utils')</code> shown above.</p>

<p>Node also supports the concept of <em>index</em> JavaScript files. To illustrate this example lets create a <em>math</em> module that will provide the <code>math.add()</code>, and <code>math.sub()</code> methods. For organizational purposes we will keep each method in their respective <em>./modules/math/add.js</em> and <em>./modules/math/sub.js</em> files. So where does <em>index.js</em> come into play? we can populate <em>./modules/math/index.js</em> with the code shown below, which is used when <code>require('./math')</code> is invoked, which is conceptually identical to invoking <code>require('./math/index')</code>.</p>

<pre><code>// modules/util.js
module.exports = {
    add: require('./add'),
    sub: require('./sub')
};</code></pre>

<p>The contents of <em>./modules/math/add.js</em> show us a new technique; here we use <code>module.exports</code> instead of <code>exports</code>.  As previously mentioned, <code>exports</code> is not the only object exposed to the module file when evaluated. We also have access to <code>__dirname</code>, <code>__filename</code>, and <code>module</code> which represents the current module. We simply define the module export object to a new object, which happens to be a function. </p>

<pre><code>// modules/math/add.js
module.exports = function add(a, b){
    return a + b;
};</code></pre>

<p>This technique is usually only helpful when your module has one aspect that it wishes to expose, be it a single function, constructor, string, etc. Below is an example of how we could provide the <code>Animal</code> constructor:</p>

<pre><code>exports.Animal = function Animal(){};</code></pre>

<p>which can then be utilized as shown:</p>

<pre><code>var Animal = require('./animal').Animal;</code></pre>

<p>if we change our module slightly, we can remove <code>.Animal</code>:</p>

<pre><code>module.exports = function Animal(){};</code></pre>

<p>which can now be used without the property:</p>

<pre><code>var Animal = require('./animal');</code></pre>

<h2 id="require_Paths">Require Paths</h2>

<p>We talked about <code>require.paths</code>, the <code>Array</code> utilized by node's module system in order to discover modules. By default, node checks the following directories for modules:</p>

<ul><li><code>&lt;node binary&gt;</code>/../../lib/node</li><li><strong>$HOME</strong>/.node_libraries</li><li><strong>$NODE_PATH</strong></li></ul>

<p>The <strong>NODE_PATH</strong> environment variable is much like <strong>PATH</strong>, as it allows several paths delimited by the colon (<code>:</code>) character.</p>

<h3 id="runtime_Manipulation">Runtime Manipulation</h3>

<p>Since <code>require.paths</code> is just an array, we can manipulate it at runtime in order to expose libraries. In our previous example we defined the libraries <em>./math/{add,sub}.js</em>, in which we would typically <code>require('./math')</code> or <code>require('./math/add')</code> etc. Another approach is to prepend or "unshift" a directory onto <code>require.paths</code> as shown below, after which we can simply <code>require('add')</code> since node will iterate the paths in order to try and locate the module.</p>

<pre><code>require.paths.unshift(__dirname + '/math');

var add = require('add'),
    sub = require('sub');

console.log(add(1,2));
console.log(sub(1,2));</code></pre>

<h2 id="pseudo_Globals">Pseudo Globals</h2>

<p>As mentioned above, modules have several pseudo globals available to them, these are as follows:</p>

<ul><li><code>require</code> the require function itself </li><li><code>module</code> the current <code>Module</code> instance</li><li><code>exports</code> the current module's exported properties</li><li><code>__filename</code> absolute path to the current module's file</li><li><code>__dirname</code> absolute path to the current module's directory</li></ul>

<p>To examine the functionality of <code>require</code>, <code>module</code>, and <code>exports</code>, open a node console by running the command <code>node</code>.  You should then enter a node prompt as seen below:</p>

<pre><code>$ node
&gt; </code></pre>

<p>To view these objects, enter the following commands into node:</p>

<pre><code>&gt; require
&gt; module
&gt; module.exports
&gt; module.filename</code></pre>

<p>If you'd like to examine other objects, the node console supports the well-known <code>&lt;TAB&gt;</code><code>&lt;TAB&gt;</code> auto-completion. </p>

<h3 id="require">require()</h3>

<p>Although not obvious at first glance, the <code>require()</code> function is actually re-defined for the current module, and calls an internal function <code>loadModule</code> with a reference to the current <code>Module</code> to resolve relative paths and to populate <code>module.parent</code>.</p>

<h3 id="module">module</h3>

<p>When we <code>require()</code> a module, typically we only deal with the module's <code>exports</code>, however the <code>module</code> variable references the current module's <code>Module</code> instance. This is why the following is valid, as we may re-assign the module's <code>exports</code> to any object, even something trivial like a string:</p>

<pre><code>// modules/css.js
module.exports = 'body { background: blue; }';</code></pre>

<p>To obtain this string we would simply <code>require('./css')</code>. The <code>module</code> object also contains these useful properties:</p>

<ul><li><code>id</code> the module's id, consisting of a path. Ex: <code>./app</code></li><li><code>parent</code> the parent <code>Module</code> (which required this one) or <code>undefined</code></li><li><code>filename</code> absolute path to the module</li><li><code>moduleCache</code> an object containing references to all cached modules</li></ul>

<h2 id="registering_Module_Compilers">Registering Module Compilers</h2>

<p>Another cool feature that node provides us is the ability to register compilers for a specific file extension. A good example of this is the CoffeeScript language, which is a ruby/python inspired language compiling to vanilla JavaScript. By using <code>require.registerExtension()</code> we can have node compile CoffeeScript to JavaScript in an automated fashion. </p>

<p>To illustrate its usage, let's create a small (and useless) Extended JavaScript language, or "ejs" for our example which will live at <em>./modules/compiler/example.ejs</em>, its syntax will look like this:</p>

<pre><code>// modules/compiler/example.ejs
::min(a, b) a &lt; b ? a : b
::max(a, b) a &gt; b ? a : b</code></pre>

<p>which will be compiled to:</p>

<pre><code>exports.min = function min(a, b) { return a &lt; b ? a : b }
exports.max = function max(a, b) { return a &gt; b ? a : b }</code></pre>

<p>First let's create the module that will actually be doing the ejs to JavaScript compilation. In this example it is located at <em>./modules/compiler/extended.js</em>, and exports a single method named <code>compile()</code>. This method accepts a string, which is the raw contents of what node is requiring, transformed to vanilla JavaScript via regular expressions.</p>

<pre><code>// modules/compiler/extended.js
exports.compile = function(str){
  return str
        .replace(/(\w+)\(/g, '$1 = function $1(')
        .replace(/\)(.+?)\n/g, '){ return $1 }\n')
        .replace(/::/g, 'exports.');
	};</code></pre>

<p>Next we have to "register" the extension to assign out compiler. As previously mentioned our compiler lives at <em>./modules/compiler/extended.js</em> so we are requiring it in.  Prior to node.js 0.3.0, we would pass the <code>compile()</code> method to <code>require.registerExtension()</code> which simply expects a function accepting a string, and returning a string of JavaScript.</p>

<pre><code>require.registerExtension('.ejs', require('./compiler/extended').compile);</code></pre>

<p>The new way to register an extension is to add a key to the require.extensions object with a function which specifies how to process the file.  For compatibility, we can use <code>require.extensions</code> and fallback to <code>require.registerExtension</code>.</p>

<pre><code>// modules/compiler.js
if(require.extensions) {
  require.extensions['.ejs'] = function(module,filename){
    var content = require('fs').readFileSync(filename, 'utf8');
    var newContent = require('./compiler/extended').compile(content);
    module._compile(newContent, filename);
  };
} else {
  require.registerExtension('.ejs', require('./compiler/extended').compile);
}</code></pre>

<p>Now when we require our example, the ".ejs" extension is detected, and will pass the contents through our compiler, and everything works as expected.</p>

<pre><code>// modules/compiler.js
var example = require('./compiler/example');
console.dir(example)
console.log(example.min(2, 3));
console.log(example.max(10, 8));</code></pre>

<p>This should display the following output when run with <code>node ./src/modules/compiler.js</code> in a terminal:</p>

<pre><code>$ node compiler.js 
{ min: [Function: min], max: [Function: max] }
2
10</code></pre>

<h2 id="patterns">Patterns</h2>

<p>  ...</p>

<h2 id="best_Practices">Best Practices</h2>

<p>  ...</p>

<h1>Globals</h1>

<p> As we have learned, node's module system discourages the use of globals. However, node provides a few important globals for us. The first, and probably the most important, is the <code>process</code> global which exposes process manipulation (e.g. signalling, exiting, process id (pid), and others). Other globals, such as the <code>console</code> object, provide JavaScript functionality common in most browsers.</p>

<h2 id="console">console</h2>

<p>The <code>console</code> object contains several methods which are used to output information to <em>stdout</em> or <em>stderr</em>. </p>

<pre><code>&gt; console
{ log: [Function],
  info: [Function],
  warn: [Function],
  error: [Function],
  dir: [Function],
  time: [Function],
  timeEnd: [Function],
  trace: [Function],
  assert: [Function] }</code></pre>

<p>Let's take a look at what each method does.</p>

<h3 id="console.log">console.log()</h3>

<p>The most frequently used console method is <code>console.log()</code>, simply writing to <em>stdout</em> with a line feed (<code>\n</code>). Currently aliased as <code>console.info()</code>.</p>

<pre><code>&gt; console.log('wahoo');
wahoo

&gt; console.log({ foo: 'bar' });
{ foo: 'bar' }</code></pre>

<h3 id="console.error">console.error()</h3>

<p>Identical to <code>console.log()</code>, however writes to <em>stderr</em>. Aliased as <code>console.warn()</code> as well.</p>

<pre><code>console.error('database connection failed');</code></pre>

<h3 id="console.dir">console.dir()</h3>

<p>Utilizes the <em>sys</em> module's <code>inspect()</code> method to pretty-print the object to
<em>stdout</em>.</p>

<pre><code>&gt; console.dir({ foo: 'bar' });
{ foo: 'bar' } </code></pre>

<h3 id="console.assert">console.assert()</h3>

<p>Asserts that the given expression is truthy, or throws an exception.  Here, you can also use <code>console.trace()</code> and <code>console.error()</code> to print a stack trace and a helpful message when the exception is caught.</p>

<pre><code>try {
   console.assert( (1 != 2), '1 != 2: Should be true' );
   console.assert( (1 == 2), '1 == 2: Should be false');
} catch(e) {
   console.error('Caught error ' + e);
   console.trace();
}</code></pre>

<h2 id="process">process</h2>

<p>The <code>process</code> object is plastered with goodies. In a node console, type <code>process</code> and look at what it has to offer. First we will take a look
at some properties that provide information about the node process itself.</p>

<h3 id="process.version">process.version(s)</h3>

<p>The <code>process.version</code> property contains the node version string, for example "v0.4.0".  The <code>process.versions</code> object displays the versions of node, v8, ares, ev, and openssl:</p>

<pre><code>&gt; process.versions
{ node: '0.4.0',
  v8: '3.1.2',
  ares: '1.7.4',
  ev: '4.3',
  openssl: '0.9.8o' }</code></pre>

<h3 id="process.installPrefix">process.installPrefix</h3>

<p>Exposes the installation prefix, which defaults to "<em>/usr/local</em>", as node's binary was installed to "<em>/usr/local/bin/node</em>".</p>

<h3 id="process.execPath">process.execPath</h3>

<p>Path to the executable itself, defaults to "<em>/usr/local/bin/node</em>".</p>

<h3 id="process.platform">process.platform</h3>

<p>Exposes a string indicating the platform you are running on, for example "darwin" or "linux".</p>

<h3 id="process.pid">process.pid</h3>

<p>The process id.</p>

<h3 id="process.cwd">process.cwd()</h3>

<p>Returns the current working directory, for example:</p>

<pre><code>$ cd /var &amp;&amp; node
&gt; process.cwd()
'/var'</code></pre>

<h3 id="process.chdir">process.chdir()</h3>

<p>Changes the current working directory to the path passed.</p>

<pre><code>&gt; process.chdir('lib')
&gt; process.cwd()
'/var/lib'</code></pre>

<h3 id="process.getuid">process.getuid()</h3>

<p>Returns the numerical user id of the running process.</p>

<h3 id="process.setuid">process.setuid()</h3>

<p>Sets the effective user id for the running process. This method accepts both a numerical id, as well as a string. For example both <code>process.setuid(501)</code>, and <code>process.setuid('tj')</code> are valid, where 501 is TJ's <em>uid</em>.</p>

<h3 id="process.getgid">process.getgid()</h3>

<p>Returns the numerical group id of the running process.</p>

<h3 id="process.setgid">process.setgid()</h3>

<p>Similar to <code>process.setuid()</code> however operates on the group, also accepting a numerical value or string representation. For example <code>process.setgid(20)</code> or <code>process.setgid('www')</code>.</p>

<h3 id="process.env">process.env</h3>

<p>An object containing the user's environment variables, for example:</p>

<pre><code>{ PATH: '/Users/tj/.gem/ruby/1.8/bin:/Users/tj/.nvm/current/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/usr/X11/bin'
, PWD: '/Users/tj/ebooks/masteringnode'
, EDITOR: 'mate'
, LANG: 'en_CA.UTF-8'
, SHLVL: '1'
, HOME: '/Users/tj'
, LOGNAME: 'tj'
, DISPLAY: '/tmp/launch-YCkT03/org.x:0'
, _: '/usr/local/bin/node'
, OLDPWD: '/Users/tj'
}</code></pre>

<h3 id="process.argv">process.argv</h3>

<p>When executing a file with the <code>node</code> executable, <code>process.argv</code> provides access to the argument vector, the first value being the node executable, second being the filename, and remaining values being the arguments passed.</p>

<p>For example, our source file <em>./src/process/misc.js</em> can be executed by running:</p>

<pre><code>$ node src/process/misc.js foo bar baz</code></pre>

<p>in which we call <code>console.dir(process.argv)</code>, outputting the following:</p>

<pre><code>[ 'node'
, '/Users/tj/EBooks/masteringnode/src/process/misc.js'
, 'foo'
, 'bar'
, 'baz'
]</code></pre>

<h3 id="process.exit">process.exit()</h3>

<p>The <code>process.exit()</code> method is synonymous with the C function <code>exit()</code>, in which a exit code &gt; 0 is passed indicating failure, or 0 to indicate success. When invoked the <em>exit</em> event is emitted, allowing a short time for arbitrary processing to occur before <code>process.reallyExit()</code> is called with the given status code.</p>

<h3 id="process.on">process.on()</h3>

<p>The process itself is an <code>EventEmitter</code>, allowing you to do things like listen for uncaught exceptions, via the <em>uncaughtException</em> event:</p>

<pre><code>// process/exceptions.js
process.on('uncaughtException', function(err){
    console.log('got an error: %s', err.message);
    process.exit(1);
});

setTimeout(function(){
    throw new Error('fail');
}, 100);</code></pre>

<h3 id="process.kill">process.kill()</h3>

<p><code>process.kill()</code> method sends the signal passed to the given <em>pid</em>, defaulting to <strong>SIGINT</strong>. In our example below we send the <strong>SIGTERM</strong> signal to the same node process to illustrate signal trapping, after which we output "terminating" and exit. Note that our second timeout of 1000 milliseconds is never reached.</p>

<pre><code>// process/kill.js
process.on('SIGTERM', function(){
    console.log('terminating');
    process.exit(1);
});

setTimeout(function(){
    console.log('sending SIGTERM to process %d', process.pid);
    process.kill(process.pid, 'SIGTERM');
}, 500);

setTimeout(function(){
    console.log('never called');
}, 1000);</code></pre>

<h3 id="errno">errno</h3>

<p><em>*TODO: Does process still support these error constants?</em></p>

<p>The <code>process</code> object is host of the error numbers, these reference what you would find in C-land, for example <code>process.EPERM</code> represents a permission based error, while <code>process.ENOENT</code> represents a missing file or directory. Typically these are used within bindings to bridge the gap between C++ and JavaScript, however useful for handling exceptions as well:</p>

<pre><code>if (err.errno === process.ENOENT) {
	// Display a 404 "Not Found" page
} else {
	// Display a 500 "Internal Server Error" page
}</code></pre>

<h1>Events</h1>

<p> The concept of an "event" is crucial to node, and used greatly throughout core and 3rd-party modules. Node's core module <em>events</em> supplies us with a single constructor, <code>EventEmitter</code>.</p>

<h2 id="emitting_Events">Emitting Events</h2>

<p>Typically an object inherits from <code>EventEmitter</code>, however our small example below illustrates the api. First we create an <code>emitter</code>, after which we can define any number of callbacks using the <code>emitter.on()</code> method which accepts the <em>name</em> of the event, and arbitrary objects passed as data. When <code>emitter.emit()</code> is called we are only required to pass the event <em>name</em>, followed by any number of arguments, in this case the <code>first</code> and <code>last</code> name strings.</p>

<pre><code>// events/basic.js
var EventEmitter = require('events').EventEmitter;

var emitter = new EventEmitter;

emitter.on('name', function(first, last){
    console.log(first + ', ' + last);
});

emitter.emit('name', 'tj', 'holowaychuk');
emitter.emit('name', 'simon', 'holowaychuk');</code></pre>

<h2 id="inheriting_From_EventEmitter">Inheriting From EventEmitter</h2>

<p>Perhaps a more practical use of <code>EventEmitter</code>, and commonly used throughout node, is to inherit from it. This means we can leave <code>EventEmitter</code>'s prototype untouched, while utilizing its api for our own means of world domination!</p>

<p>To do so we begin by defining the <code>Dog</code> constructor, which of course will bark from time to time, also known as an <em>event</em>.</p>

<pre><code>// events/subclass.js
var EventEmitter = require('events').EventEmitter;

function Dog(name) {
    this.name = name;
}</code></pre>

<ul><li>Note: JavaScript doesn't have 'classes'.  The file above is called 'subclass' because this is a term commonly used for inheritance in an object-oriented language.*</li></ul>

<p>Here we inherit from <code>EventEmitter</code>, so that we may use the methods provided such as <code>EventEmitter#on()</code> and <code>EventEmitter#emit()</code>. If the <code>__proto__</code> property is throwing you off, no worries! we will be touching on this later.</p>

<pre><code>Dog.prototype.__proto__ = EventEmitter.prototype;</code></pre>

<p>Now that we have our <code>Dog</code> set up, we can create .... simon! When simon barks we can let <em>stdout</em> know by calling <code>console.log()</code> within the callback. The callback it-self is called in context to the object, aka <code>this</code>.</p>

<pre><code>var simon = new Dog('simon');

simon.on('bark', function(){
    console.log(this.name + ' barked');
});</code></pre>

<p>Bark twice a second:</p>

<pre><code>setInterval(function(){
    simon.emit('bark');
}, 500);</code></pre>

<p>You may look at the above code and think, "Why don't I just add a <em>bark</em> function?"  That's a good question.  The power of events is in subscribing to events that occur when a function on the object is executed.  For instance, if you have a writeable <code>Stream</code> object with the function <code>write()</code>, you may subscribe to a data event.  The following event example is directly from the node api documentation:</p>

<pre><code>// events/streams.js
var util = require("util");
var events = require("events");

function MyStream() {
    events.EventEmitter.call(this);
}

util.inherits(MyStream, events.EventEmitter);

MyStream.prototype.write = function(data) {
    this.emit("data", data);
}

var stream = new MyStream();

console.log(stream instanceof events.EventEmitter); // true
console.log(MyStream.super_ === events.EventEmitter); // true

stream.on("data", function(data) {
	console.log('Received data: "' + data + '"');
});
stream.write("It works!"); // Received data: "It works!"</code></pre>

<p>This example is fairly complicated compared to most of the examples so far.  It does a number of things that haven't yet been covered, but are included here for completeness.  First of all, we're creating an object of <code>MyStream</code> called <code>stream</code>, which inherits from <code>EventEmitter</code>. This was mentioned earlier, but the api's example provides a nice use of the util module for inheritance.  Then, we set the <code>write</code> function to emit the <em>data</em> event to any subscribers (which are called <em>EventListeners</em>).  In this function, we could also provide some default functionality (more than emitting an event), such as writing to an inner sink, logging, or any number of operations.</p>

<p>After setting up the object, this example writes to <code>console.log()</code> to demonstrate that both the stream and the <code>super_</code> object are instances of <code>EventEmitter</code>.  Afterward, we subscribe to the <code>"data"</code> event and log the data that is emitted from the <code>MyStream.prototype.write</code> function.  This means that anything passed to the <code>write()</code> function is emitted to all subscribers as the single object passed to the callback function.  In other words, anytime we call <code>write()</code>, we're going to log with a little message to show that the parameter is being written by the emitted event.</p>

<p>So, unlike the dog barking example, this shows that a single function can have multiple operations occur via events.</p>

<p><strong>Note: when adding an event, it is pushed onto the end of an array of existing events</strong> </p>

<h2 id="removing_Event_Listeners">Removing Event Listeners</h2>

<p>As we have seen, event listeners are simply functions which are called when we <code>emit()</code> an event. Although not seen often, we can remove these listeners by calling the <code>removeListener(type, callback)</code> method. In the example below, we emit the <em>message</em> <code>'foo bar'</code> every <code>300</code> milliseconds, which has the callback of <code>console.log()</code>. After 1000 milliseconds we call <code>removeListener()</code> with the same arguments that we passed to <code>emitter.on()</code> originally. To complement this method is <code>removeAllListeners(type)</code>, which removes all listeners associated to the given <em>type</em>.</p>

<pre><code>// events/removing.js
var EventEmitter = require('events').EventEmitter;

var emitter = new EventEmitter;

emitter.on('message', console.log);

setInterval(function(){
    emitter.emit('message', 'foo bar');
}, 300);

setTimeout(function(){
    emitter.removeListener('message', console.log);
}, 1000);</code></pre>

<h1>Buffers</h1>

<p>To handle binary data, node provides us with the global <code>Buffer</code> object. Buffer instances represent memory allocated independently to that of V8's heap. There are several ways to construct a <code>Buffer</code> instance, and many ways you can manipulate it's data.</p>

<p>The simplest way to construct a <code>Buffer</code> from a string is to pass a string as the first argument to <code>Buffer</code>'s constructor. As you can see by the log output, we now have a buffer object containing 5 bytes of data represented in hexadecimal.</p>

<pre><code>&gt; var hello = new Buffer('Hello');

&gt; console.log(hello);
&lt;Buffer 48 65 6c 6c 6f&gt;

&gt; console.log(hello.toString());
'Hello'</code></pre>

<p>By default the encoding is "utf8", however this can be specified by passing as string as the second argument. The ellipsis below for example will be printed to stdout as the '&amp;' character when in "ascii" encoding.</p>

<pre><code>&gt; var buf = new Buffer('…');
&gt; console.log(buf.toString());
'…'

&gt; var buf = new Buffer('…', 'ascii');
&gt; console.log(buf.toString());
'&amp;'</code></pre>

<p>An alternative method is to pass an array of integers representing the octet stream.</p>

<pre><code>&gt; var h = [0x48, 0x65, 0x6c, 0x6c, 0x6f];
&gt; h
[ 72, 101, 108, 108, 111 ]

&gt; h.toString();
'72,101,108,108,111'

&gt; var hello = new Buffer(h);
&lt;Buffer 48 65 6c 6c 6f&gt;

&gt; hello.toString();
'Hello'</code></pre>

<p>Buffers can also be created with an integer representing the number of bytes allocated, after which we may call the <code>write()</code> method, providing an optional offset and encoding. As shown below, we create a buffer large enough to hold the string "Hello World!"  After writing 'Hello', we see the bytes 5 through 12 are unused bytes.  We then write ' World' starting at byte 6 and examine the output.  Whoops!  We skipped a byte.  We can overwrite this part of the buffer with ' World!' starting at byte 5.  We then call <code>toString()</code> on the buffer and see that the buffer is now filled with the desired string.</p>

<pre><code>&gt; var hello = new Buffer(12);
&gt; hello.write('Hello');
5

&gt; hello.toString();
'Hello\u0000�̵\u0001\u0000\u0000'
&gt; hello.write(' World', 6);
6

&gt; hello.toString();
'Hello\u0000 World'

&gt; hello.write(' World!', 5);
7

&gt; hello.toString();
'Hello World!'

&gt; hello.length
12</code></pre>

<p>The <code>length</code> property of a buffer instance contains the byte length of the stream, opposed to JavaScript strings which will simply return the number of characters. For example the ellipsis character '…' consists of three bytes, however the buffer will respond with the byte length, and not the character length.</p>

<pre><code>&gt; var ellipsis = new Buffer('…', 'utf8');
&gt; console.log('… string length: %d', '…'.length);
… string length: 1

&gt; console.log('… byte length: %d', ellipsis.length);
… byte length: 3

&gt; ellipsis
&lt;Buffer e2 80 a6&gt;</code></pre>

<p>When dealing with a JavaScript string, we may pass it to the <code>Buffer.byteLength()</code> method to determine it's byte length.</p>

<pre><code>&gt; Buffer.byteLength('…');
3</code></pre>

<p>The api is written in such a way that it is String-like, so for example we can work with "slices" of a <code>Buffer</code> by passing offsets to the <code>slice()</code> method:</p>

<pre><code>&gt; var chunk = buf.slice(4, 9);
&gt; console.log(chunk.toString());
'some'</code></pre>

<p>Alternatively when expecting a string we can pass offsets to <code>Buffer#toString()</code>:</p>

<pre><code>&gt; var buffer = new Buffer('The quick brown fox');
&gt; buffer.toString('ascii', 4, 9);
'quick'</code></pre>

<p>A Buffer object has a number of helper functions: <code>.utf8Write()</code>, <code>.utf8Slice()</code>, <code>.asciiWrite()</code>, <code>.asciiSlice()</code>, <code>.binaryWrite()</code>, <code>.binarySlice()</code>.  These methods provide similar functionality while enforcing proper encoding.</p>

<h1>Streams</h1>

<p>Streams are an important concept in node. The stream api is a unified way to handle stream-like data, for example data can be streamed to a file, streamed to a socket to respond to an HTTP request, or a stream can be read-only such as reading from <em>stdin</em>. However since we will be touching on stream specifics in later chapters, for now we will concentrate on the api.</p>

<h2 id="readable_Streams">Readable Streams</h2>

<p>Readable streams such as an HTTP request inherit from <code>EventEmitter</code> in order to expose incoming data through events. The first of these events is the <em>data</em> event, which is an arbitrary chunk of data passed to the event handler as a <code>Buffer</code> instance. </p>

<pre><code>req.on('data', function(buf){
    // Do something with the Buffer
});</code></pre>

<p>As we know, we can call <code>toString()</code> a buffer to return a string representation of the binary data, however in the case of streams if desired we may call <code>setEncoding()</code> on the stream,
after which the <em>data</em> event will emit strings.</p>

<pre><code>req.setEncoding('utf8');
req.on('data', function(str){
    // Do something with the String
});</code></pre>

<p>Another import event is the <em>end</em> event, which represents the ending of <em>data</em> events. For example below we define an HTTP echo server, simply "pumping" the request body data through to the response. So if we <strong>POST</strong> "hello world", our response will be "hello world".</p>

<pre><code>// streams/echo.js
var http = require('http');

http.createServer(function(req, res){
    res.writeHead(200);
    req.on('data', function(data){
        res.write(data);
    });
    req.on('end', function(){
        res.end();
    });
}).listen(3000);</code></pre>

<p>The <em>sys</em> module actually has a function designed specifically for this "pumping" action, aptly named <code>sys.pump()</code>, which accepts a read stream as the first argument, and write stream as the second.</p>

<pre><code>// streams/pump.js
var http = require('http'),
    sys = require('sys');

http.createServer(function(req, res){
    res.writeHead(200);
    sys.pump(req, res);
}).listen(3000);</code></pre>

<h1>File System</h1>

<p>  To work with the filesystem, node provides the 'fs' module. The commands follow the POSIX operations, with most methods supporting an asynchronous and synchronous method call. We will look at how to use both and then establish which is the better option.</p>

<h2 id="working_with_the_filesystem">Working with the filesystem</h2>

<p>  Lets start with a basic example of working with the filesystem, this example creates a directory, it then creates a file in it. Once the file has been created the contents of the file are written to console:</p>

<pre><code>// fs/basics.js
var fs = require('fs');

fs.mkdir('./helloDir',0777, function (err) {
  if (err) throw err;

  fs.writeFile('./helloDir/message.txt', 'Hello Node', function (err) {
    if (err) throw err;
    console.log('file created with contents:');

    fs.readFile('./helloDir/message.txt','UTF-8' ,function (err, data) {
      if (err) throw err;
      console.log(data);
    });
  });
});</code></pre>

<p>  As evident in the example above, each callback is placed in the previous callback - this is what is referred to as chainable callbacks. When using asynchronous methods this pattern should be used, as there is no guarantee that the operations will be completed in the order that they are created. This could lead to unpredictable behavior.</p>

<p>  The example can be rewritten to use a synchronous approach:</p>

<pre><code>fs.mkdirSync('./helloDirSync',0777);
fs.writeFileSync('./helloDirSync/message.txt', 'Hello Node');
var data = fs.readFileSync('./helloDirSync/message.txt','UTF-8');
console.log('file created with contents:');
console.log(data);</code></pre>

<p>  It is better to use the asynchronous approach on servers with a high load, as the synchronous methods will cause the whole process to halt and wait for the operation to complete. This will block any incoming connections and other events.</p>

<h2 id="file_information">File information</h2>

<p>The fs.Stats object contains information about a particular file or directory. This can be used to determine what type of object we are working with. In this example we are getting all the file objects in a directory and displaying whether they are a file or a directory object.</p>

<pre><code>// fs/stat.js
var fs = require('fs');

fs.readdir('/etc/', function (err, files) {
  if (err) throw err;

  files.forEach( function (file) {
    fs.stat('/etc/' + file, function (err, stats) {
      if (err) throw err;

      if (stats.isFile()) {
        console.log("%s is file", file);
      }
      else if (stats.isDirectory ()) {
      console.log("%s is a directory", file);
      }    
    console.log('stats:  %s',JSON.stringify(stats));
    });
  });
});</code></pre>

<h2 id="watching_files">Watching files</h2>

<p>  The fs.watchfile monitors a file and will fire the event whenever the file is changed.</p>

<pre><code>// fs/watch.js
var fs = require('fs');

fs.watchFile('./testFile.txt', function (curr, prev) {
  console.log('the current mtime is: ' + curr.mtime);
  console.log('the previous mtime was: ' + prev.mtime);
});

fs.writeFile('./testFile.txt', "changed", function (err) {
  if (err) throw err;

  console.log("file write complete");   
});</code></pre>

<p>  A file can also be unwatched using the fs.unwatchFile method call. This is used once monitoring of a file is no longer required.</p>

<h2 id="nodejs_Docs_for_further_reading">Nodejs Docs for further reading</h2>

<p>  The node api <a href="http://nodejs.org/api.html#file-system-106">docs</a> are very detailed and list all the possible filesystem commands available when working with Nodejs.</p>

<h1>TCP</h1>

<p>  ...</p>

<h2 id="tCP_Servers">TCP Servers</h2>

<p>Many times, a server will do two things: write data to the console and send data to a client connection.  Below is a simple TCP server which echos "You were connected!" to a client connection and outputs "A client has connected!" to <em>stdout</em>.</p>

<pre><code>// tcp/tcp_server.js
var sys = require('sys');
var tcp = require('net');
var server = tcp.createServer({ allowHalfOpen:false }, function(socket) {
    sys.puts("A client has connected!");
    socket.write("You were connected!\n", "utf8");
    socket.end();
}).listen(8000, '127.0.0.1');</code></pre>

<p>To test this server, enter <code>node src/tcp/tcp_server.js</code> in a terminal.  Then, open another terminal to telnet into this server.</p>

<pre><code>$ telnet 127.0.0.1 8000</code></pre>

<p>In the server's terminal, you should see the message output from <code>sys.puts</code>, while the client's server should display, "You were connected!"</p>

<h2 id="tCP_Clients">TCP Clients</h2>

<p> ...</p>

<h1>HTTP</h1>

<p>Node's HTTP module offers a chunkable, buffered interface to the HTTP protocol.  Headers are JSON objects with lower-case keys and original values.</p>

<pre><code>{ 'content-length': '123', 'content-type': 'text/plain' }</code></pre>

<p>The HTTP module is low-level, meaning it handles the headers and the message (and that's about it).  This creates a solid framework ontop of which modules can be built for web frameworks (<a href="http://www.expressjs.com">express</a>, <a href="http://www.geddy.com">geddy</a>, file servers, browsers (<a href="http://www.google.com/?q=zombiejs">zombie.js</a>, and even SaaS (<a href="http://www.cloud9ide.com)">cloud9 IDE</a>.</p>

<p>Let's take a look at the <code>request</code> and <code>response</code> objects of an HTTP server created by node.  To do this, we're going to create a server, inspect both of these objects in the request, and write a dump of the inspection out to a file.</p>

<pre><code>// http/view_request.js
var http = require('http'), 
fs = require('fs'), 
util = require('util'),
tty = require('tty');

var server = http.createServer(function(req, res) {
    console.log("Received a request!");
    fs.writeFile('./request.txt', util.inspect(req) );
    res.writeHead(200, { 'Content-Type' : 'text/html' });
    res.write("&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello, World!&lt;/h1&gt;&lt;p&gt;We're serving up html!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;");
    res.end();
    fs.writeFile('./response.txt', util.inspect(res) );
});

// ... cleanup on exit (see file)

console.log("Server is running on http://localhost:9111");
console.log("Hit CTRL+C to shutdown the http server");</code></pre>

<p>Run this sample with <code>node src/http/view_request.js</code> from a terminal.  Then, navigate to the server location displayed in the terminal.  This will generate two files: <code>./src/http/request.txt</code> and <code>./src/http/response.txt</code>.</p>

<p><em>!IMPORTANT!</em> You must always remember to provide a way to close a server.  Leaving an open server running developmental code can be a security risk.</p>

<h2 id="hTTP_Request">HTTP Request</h2>

<p>Let's take a look at what the request object looks like from the server example above. You should see output similar to:</p>

<pre><code>// http/request.txt
// ...
httpVersion: '1.1',
  complete: false,
  headers: 
   { host: 'localhost:9111',
     connection: 'keep-alive',
     accept: '*/*',
     'user-agent': 'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.14 Safari/534.24',
     'accept-encoding': 'gzip,deflate,sdch',
     'accept-language': 'en-US,ru;q=0.8',
     'accept-charset': 'ISO-8859-1,utf-8;q=0.7,*;q=0.3' },
  trailers: {},
  readable: true,
  url: '/favicon.ico',
  method: 'GET',
  statusCode: null, 
// ...</code></pre>

<h2 id="hTTP_Response">HTTP Response</h2>

<p>Let's take a look at what the request object looks like from the server example above. You should see output similar to:</p>

<pre><code>{ output: [],
  outputEncodings: [],
  writable: true,
  _last: false,
  chunkedEncoding: true,
  shouldKeepAlive: true,
  useChunkedEncodingByDefault: true,
  _hasBody: true,
  _trailer: '',
  finished: true,
  socket: null,
  connection: null,
  _events: { finish: [Function] },
  _header: 'HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nConnection: keep-alive\r\nTransfer-Encoding: chunked\r\n\r\n',
  _headerSent: true }</code></pre>

<h2 id="hTTP_Servers">HTTP Servers</h2>

<p>http.Server exposes a number of events (request, connection, close, response, etc.) and three functions for creation, listening for requests, and closing the server.  We saw examples of a few of these at the beginning of this section. Up to this point, most of the code we've looked at has been mainly procedural.  To create a server, we will have to implement quite a few things we've learned up to this point:</p>

<ul><li>Write a module for an http server</li><li>Expose events which occur on the server</li><li>Serve/compile files</li></ul>

<p>Like the first example in this chapter, we'll be using the <em>http</em>, <em>fs</em> and <em>tty</em> modules.  To make this interesting, though, we'll also do a compilation from markdown to html so that our server is doing a little more than serving static files. To simplify the example, we won't also be serving static files or even sending a full range of HTTP status codes; everything is <code>200 OK</code> in this example.</p>

<h3 id="creating_the_module">Creating the module</h3>

<p>Our module will be located at <code>./src/http/server/</code>.  The directory is structured in the following way:</p>

<pre><code>$ ls -l
total 20
drwxr-xr-x 3 jim jim 4096 2011-03-23 16:31 lib
-rw-r--r-- 1 jim jim   56 2011-03-23 17:13 package.json
drwxr-xr-x 2 jim jim 4096 2011-03-24 07:25 pages
-rw-r--r-- 1 jim jim 3034 2011-03-24 07:57 server.js
drwxr-xr-x 2 jim jim 4096 2011-03-23 20:31 templates</code></pre>

<p>The file <code>server.js</code> is our module.  So we don't need to call <code>var server = require('./server/server.js')</code> at the top of our node application, we're also going to include <code>package.json</code> which specifies where the main routine for our module is located.</p>

<pre><code>// http/server/package.json
{ "name" : "example server",
  "main" : "./server.js" }</code></pre>

<p>Recall from the <em>Modules</em> chapter that it is also possible to include an <code>index.js</code> file.  </p>

<p>Next, let's identify the functionality we'll require in this module.  First, we know that we'll have to read a file.  We'll call that function <code>getFile()</code>. Then, since we're simplifying things for example's sake, we're assuming all files are in markdown format and converting all files to html.  We'll call that function <code>getHtml()</code>.  I know, I'm really creative.</p>

<p>Finally, we'll have a function called <code>run()</code> which creates the server and listens on the specified port.  To make our module useful, we have to expose functionality which, in our case, is only the run method.  Here is how we will interface with our module:</p>

<pre><code>// http/server_example.js
var server = require('./server');
server.run({ port: 9222 });</code></pre>

<p>We also have the option of performing a function before starting the server:</p>

<pre><code>server.run({ port: 9222, 
    beforeStart: function(){ 
        console.log("before start");
    } 
});</code></pre>

<p>Now that we have a plan in place for the interaction with the module, let's take a look at the three functions, <code>getFile()</code>, <code>getHtml()</code>, and <code>run()</code>.</p>

<p><strong> getFile(request) </strong></p>

<p>The <code>getFile()</code> function assumes that all requests occur at the base of the server's uri. It also ignores requests for <code>/favicon.ico</code> and for the base uri <code>/</code>.  It then builds a full path to the file and attempts to read the file in a single blocking call. This blocking call helps ensure that we're passing data correctly to the Markdown module.</p>

<pre><code>// http/server/server.js
var getFile = function(request) {
    if(!request) {
        console.log("getFile called with empty request");
        noop();
    }

   var callback = arguments[arguments.length - 1];
   if (typeof(callback) !== 'function') callback = noop;

   var filename = url.parse(request).pathname.replace('html', 'md');
   if(filename === "/favicon.ico") return;
   if(filename === "/" || filename === "") { filename = "/index.md"; }

   var requestedFile = __dirname + '/pages' + filename;

   console.log('Requested: ' + requestedFile);
   var data = fs.readFileSync(requestedFile, "utf8");
   callback(data);
};</code></pre>

<p>This function uses the same pattern of identifying a callback as the node libraries.  The <code>noop()</code> function is defined as <code>var noop = function() { };</code> which saves us from creating numerous empty callbacks and checking for functions where those callbacks are required.  For those unfamiliar with the term <em>noop</em>, it means the function performs <strong>no op</strong>eration.</p>

<p><strong> getHtml(request) </strong></p>

<p>The second function in our module performs the conversion between markdown and html.  It does this in the callack to the <code>getFile()</code> function, transforms the markdown to html, and passes the result to its own callback. </p>

<pre><code>// http/server/server.js
var getHtml = function(request) {
    var callback = arguments[arguments.length - 1];
    if (typeof(callback) !== 'function') callback = noop;

    // get the data and call markdown
    try {
        getFile(request, function(data) {
            if(!data) { 
                callback("Nothing to see here!");
            }
            var html = template.replace("{{content}}", markdown.toHTML(markdown.parse(data), {xhtml:true}));
            console.log(html);
            callback(html);
        }); 
    } catch(err) {
        console.log(err);
        callback("Nothing to see here!");
    }
}; </code></pre>

<p>If there are any errors, it returns a string: "Nothing to see here!" A message like this usually accompanies a <code>404 - Not Found</code> HTTP status, but we're keeping this pretty simple.</p>

<p><strong> run() </strong></p>

<p>The run function requires the following server to be created.  The <code>requestListener</code> function calls <code>getHtml</code> and writes the html to the response.  Here, we're using a buffer to get the proper byte length and attempt to output a properly-encoded html string.</p>

<pre><code>// http/server/server.js
var server = http.createServer(function(req, res) {
    getHtml(req.url, function(html) {
        var buf = new Buffer(html, "utf8");
        res.writeHead(200, { 'Content-Type' : 'text/html', 'Content-Length' : buf.length });
        res.write(buf.toString());
        res.end();
    });
});</code></pre>

<p>Next, the run function sets the options we're allowing (port number and a function to call before starting the server).  We're also catching all errors and logging the output to the console.  </p>

<pre><code>// http/server/server.js
var run = function(opts) {
    try {
        if(opts &amp;&amp; typeof opts['beforeStart'] === 'function'){
            opts['beforeStart']();
        }
        var port = (opts &amp;&amp; opts.port) || 9111;

        // ... Removed CTRL+C interrupt code from previous example

        server.listen(port, function() {
            console.log("Server is running on http://localhost:" + port);
            console.log("Hit CTRL+C to shutdown the http server");
        });
    } catch(err) {
        console.log(err);
    }
};</code></pre>

<p>Notice how we've moved the console logging to the <code>server.listen</code> callback.  This makes more sense than the procedural example from before- if the port isn't available and <code>server.listen</code> throws an error, you don't want to tell the developer that the server has started!  This is how things should be programmed, and it's part of what makes node.js so awesome.</p>

<p><strong> Exposing <code>run()</code> </strong></p>

<p>The last thing to do to make our module run is to expose the run function.  To revisit from the <em>Modules</em> chapter, you can do this a few ways:</p>

<pre><code>// 1. Multiple assignment
var server = exports.server = http.createServer(requestListener);

// 2. Inline assignment
exports.server = http.createServer(requestListener);

// 3. Post-facto assignment
var server = http.createServer(requestListener);
exports.server = server;</code></pre>

<p>There's no 'correct' method, and each has it's benefits. Please refer to the <em>Best Practices</em> section for more information.</p>

<p><strong> Run it! </strong></p>

<pre><code>$ node src/http/server_example.js 
Server is running on http://localhost:9222
Hit CTRL+C to shutdown the http server</code></pre>

<p>After receiving the output to confirm the server is running, visit <a href="http://localhost:9222">http://localhost:9222</a> to check it out.  Then, hit <code>CTRL+C</code> to be sure the server's <code>close</code> function is working as expected.</p>

<p><strong> Where are the events? </strong></p>

<p>You may have noticed that we met only half of the requirements with the above implementation of our server.  To expose events, our <code>run</code> method would have to inherit from <code>EventEmitter</code>. That doesn't <em>really</em> make sense.  For the sake of simplicity and brevity, we previously only had three methods.  We had no class-like objects, and we didn't touch an object's prototype.  Also, the three methods we did have didn't make good use of callbacks.  So, there is another take on this example at <em>./src/http/server/server2.js</em>.</p>

<p>This is set up so that our <code>run</code> function returns our <code>Example</code> object. This object has properties for our configurables (such as the pages directory, template name, etc.).  It also has the functions from the previous example, which have been slightly refactored.</p>

<p>First, you'll notice the inheritence of the <code>Example</code> object from <code>EventEmitter</code>:</p>

<pre><code>// http/server/server2.js
util.inherits(Example, EventEmitter);</code></pre>

<p>This allows us to call <code>this.emit('eventName')</code> at different times in our code, which executes all of the listeners bound to these events in the order they were declared.</p>

<p>Now, at different points of the code, you'll see a <code>this.emit()</code> or <code>self.emit()</code> call.  For instance, in the <code>getServer</code> function, we emit the <code>request</code> and <code>requestComplete</code> events.</p>

<pre><code>// http/server/server2.js
Example.prototype.getServer = function() {
	var self = this, ct = 'text/html; charset=utf-8';
	return http.createServer(function(req, res) {
		self.emit('request', req.url);
		self.getHtml(req.url, function(html) {
			var buf = new Buffer(html, "utf8");
			res.writeHead(200, 
				{ 
					'Content-Type' : ct, 
				 	'Content-Length' : buf.length 
			 	});
			res.write(buf.toString());
			res.end();
			self.emit('requestComplete');
		});
	});
};</code></pre>

<p>Because we know that all responses will be <em>html</em>, the request comes in and immediate emits the <code>request</code> event.  Our <code>getHtml</code> function is written to do one of two things. First, it gets a valid string of html, emits it as <em>data</em> to the <code>data</code> event, then passes it to <code>getHtml</code>'s callback as the <em>html</em> parameter, which ultimately writes that string to the response. </p>

<p>The alternative is when a request is ignored either explicitly with the <code>option.ignorePaths</code> array, or implicitly by <code>fs.readFileSync</code> throwing an error.  Either way, we emit the <code>data</code> event with the content as "ignored".  The <code>getHtml</code> function above then writes an empty response.</p>

<h2 id="hTTP_Clients">HTTP Clients</h2>

<p> ...</p>

<h2 id="url_Module">Url Module</h2>

<p> ...</p>

<h2 id="micro_Frameworks">Micro-Frameworks</h2>

<h3 id="geddy">Geddy</h3>

<p>...</p>

<h3 id="zombieJS">ZombieJS</h3>

<p>...</p>

<h3 id="cloud9_IDE">cloud9 IDE</h3>

<p>...</p>

<h1>HTTPS</h1>

<h2 id="hTTPS_Server">HTTPS Server</h2>

<h2 id="hTTPS_Client">HTTPS Client</h2>

<h1>Connect</h1>

<p>Connect is a ...</p>

<h1>Express</h1>

<p><a href="www.expressjs.com">Express</a> is a robust and feature-rich web application framework for node.js written by TJ Holowaychuk, Ciaran Jessup, Aaron Heckmann, and Guillermo Rauch.  </p>

<h2 id="install">Install</h2>

<h2 id="simple_First_Project">Simple First Project</h2>

<h1>Testing</h1>

<p>Testing is a very large topic.  There are different types of testing, each with different methodologies.  Then, there are also strong feelings of developers toward which type of testing is the best or most effective.</p>

<ul><li>Assertion Testing<ul><li>Tests a true or false condition against known objects or values</li></ul></li><li>Behavioral Testing<ul><li>Tests how one object acts when interacting with another</li></ul></li><li>Functional/Acceptance Testing<ul><li>"Black box" testing of a system, usually code-agnostic</li></ul></li><li>Regression Testing<ul><li>Tests for consistency after changes have been made to code</li></ul></li><li>Others...</li></ul>

<p>There are many other types of testing, but these are some large topics in the testing arena.  Development practices include Test-Driven Development (TDD), Behavior-Driven Development, and others. Some programmers don't believe in testing, others believe tests should be written before the code, while others still believe tests should only be written for the most important code.  As you can see, this is a large and complex topic.</p>

<p>Whether you write tests before you code, test only the most important code, or casually write tests when there is time, it is important to choose a testing tool that fits your needs.</p>

<h2 id="assert_Module">assert Module</h2>

<p>To begin, require the assert module:</p>

<pre><code>var assert = require('assert');</code></pre>

<p>This module exposes a few functions common to assertion testing:</p>

<pre><code>// equality
assert.equal(actual, expected, [message])
assert.notEqual(actual, expected, [message])
assert.deepEqual(actual, expected, [message])
assert.notDeepEqual(actual, expected, [message])
assert.strictEqual(actual, expected, [message])
assert.notStrictEqual(actual, expected, [message])

// exception
assert.throws(block, [error], [message])
assert.doesNotThrow(block, [error], [message])
assert.ifError(value)

// condition
assert.ok(value, [message])
assert.fail(actual, expected, message, operator)</code></pre>

<p>These are pretty self-explanatory if you've written assertion tests before. Let's look at a pretty simple test, anyway.  We'll code in an object for the test that will do what we want for each test.</p>

<h3 id="synchronous_Testing_with_Assert">Synchronous Testing with Assert</h3>

<pre><code>// testing/equality_no_errors.js
var assert = require('assert'),
    tester_a = {
      val : 'a'
    }, 	
    tester_b = {
      val : 'b'
    };

assert.equal(tester_a.val, 'a');
assert.equal(tester_b.val, 'b');</code></pre>

<p>In this example, we're using the assert module to check that a value on each of these objects is the expected value.  This works well because the values are equal.  But, the assert module throws an <code>AssertionError</code> whenever an assertion fails.  So, it doesn't really make sense to have a single file with end-to-end assertions as in the <code>./src/testing/equality\_no\_errors.js</code> file.  This is where testing frameworks like <em>nodeunit</em> or <em>expresso</em> come in very handy.  They offer common functionality of test frameworks (like metrics, etc.).</p>

<p>To see how the <code>AssertionError</code> being thrown from <code>assert.equal</code> can be problematic, change the expected value in the first test to an incorrect value.  Then, change the expected value in the very last test to an incorrect value and run <code>node src/testing/equality_no_errors.js</code> again.  You'll see that, because of the procedural style of the code, the last test never runs!  </p>

<p>In order to run multiple assertions and provide feedback, the simplest test (without a testing framework) would use a <code>try/catch</code> and provide output to <em>stdout</em>.</p>

<pre><code>// testing/equality_with_errors.js
var assert = require('assert'),
    tester_a = {
      val : 'aa'
    }, total = 0, good = 0;

// assert.equal(actual, expected, [message])
try {
    console.log("assert.equal(tester_a.val, 'a')");
    assert.equal(tester_a.val, 'a');
    passed();
} catch (err) { writeException(err); }

console.log("%d of %d tests passed", good, total);

function writeException(err) {
    console.log("Test failed!");
    util.inspect(err);
    if(err["name"] === "AssertionError") {
        console.log("Message: " + (err["message"] || "None"));
        console.log("Expected: " + err["expected"]);
        console.log("Actual: " + err["actual"]);
        console.log("Operation: " + err["operator"]);
    }
    console.log("");
    total = total + 1;
}

function passed() {
    good = good + 1;
    total = total + 1;
    console.log("Test passed!\n");
}</code></pre>

<p>The above code is part of the code from within <em>./src/testing/equality_with_errors.js</em>.  It shows how to run synchronous tests with a minimal amount of redundant code, <em>without</em> writing a lightweight testing module for your tests.  This may be what you want, but most likely it isn't.</p>

<h3 id="the_problems">The problems</h3>

<p>You <em>could</em> write a simple helper module to run these tests for you.  But, how do you verify the order of your tests?  This can become complex very quickly.</p>

<p>You can partially resolve this with the <code>try/catch</code> block example above, but this requires a lot of redundant code.  Compare <em>./src/testing/equality_with_errors.js</em> and <em>./src/testing/equality_no_errors.js</em> to see how the testing quickly expands!  Run <code>node testing/equality_with_errors.js</code> to see the output.  That's more like it! Isn't that nice?  </p>

<p>Yes and no.  There are a few problems with this code: </p>

<ol><li>It isn't evented</li><li>It hard-codes test objects</li><li>It is very redundant</li><li>It isn't scalable</li></ol>

<p>Well, then, <em>what are other options?</em></p>

<h2 id="nodeunit">Nodeunit</h2>

<p><a href="https://github.com/caolan/nodeunit">Nodeunit</a> is a framework similar to nunit in that it allows for multiple test cases (running in parallel), and supports mocks and stubs.  It is easy to use, and even allows you to run tests in the browser.</p>

<p>Nodeunit testing starts with exporting a test or two from a module.</p>

<pre><code>// testing/nodeunit_basics.js
module.exports = {
    'Test 1' : function(test) {
        test.expect(1);
        test.ok(true, "This shouldn't fail");
        test.done();
    },
    'Test 2' : function(test) {
        test.expect(2);
        test.ok(1 === 1, "This shouldn't fail");
        test.ok(false, "This should fail");
        test.done();
    }
};</code></pre>

<p>Here, we have a module exporting two tests, <code>Test 1</code> and <code>Test 2</code>.  You may have noticed that the <code>test</code> object in the functions have an <code>ok()</code> method just like the <code>assert</code> module mentioned above.  Good eye.  In fact, <code>test</code> supports all of the assert functions and adds two others: <code>expect(number)</code> and <code>done()</code>.  The <code>expect</code> function tells nodeunit how many tests are being run within the context of the current test case.  When all tests are finished, call <code>test.done()</code> to let nodeunit know the test case has completed (and a callback may have failed).</p>

<p>The output of nodeunit is visually helpful.  </p>

<pre><code>$ nodeunit src/testing/nodeunit_basics.js 

nodeunit_basics.js
✔ Test 1
✖ Test 2

Assertion Message: This should fail
AssertionError: false == true
    at Object.ok (/usr/local/lib/node/.npm/nodeunit/0.5.1/package/lib/types.js:81:39)
    at /home/jim/projects/masteringnode/src/testing/nodeunit_basics.js:10:14
    at Object.runTest (/usr/local/lib/node/.npm/nodeunit/0.5.1/package/lib/core.js:54:9)
    at /usr/local/lib/node/.npm/nodeunit/0.5.1/package/lib/core.js:90:21
    at /usr/local/lib/node/.npm/nodeunit/0.5.1/package/deps/async.js:508:13
    at /usr/local/lib/node/.npm/nodeunit/0.5.1/package/deps/async.js:118:25
    at /usr/local/lib/node/.npm/nodeunit/0.5.1/package/deps/async.js:129:25
    at /usr/local/lib/node/.npm/nodeunit/0.5.1/package/deps/async.js:510:17
    at Array.&lt;anonymous&gt; (/usr/local/lib/node/.npm/nodeunit/0.5.1/package/lib/types.js:144:17)
    at EventEmitter._tickCallback (node.js:108:26)


FAILURES: 1/3 assertions failed (8ms)</code></pre>

<p>Nodeunit will list all test cases run within the test, followed by any <code>AssertionError</code> output and the number of passing or failing assertions.  This is the default (minimal) output.  </p>

<h3 id="nodeunit_reporters">Nodeunit reporters</h3>

<p>Nodeunit ships with a number of reporters and it is possible to add custom reporters.  </p>

<pre><code>$ nodeunit --list-reporters
Build-in reporters: 
  * default: Default tests reporter
  * minimal: Pretty minimal output
  * junit: jUnit XML test reports
  * html: Report tests result as HTML
  * skip_passed: Skip passed tests output
  * browser: Browser-based test reporter</code></pre>

<p>To output to junit, run the command as:</p>

<pre><code>$ cd src/testing &amp;&amp; nodeunit --reporter junit nodeunit_basics.js --output junit.out</code></pre>

<p>This creates an xml file (whitespace has been condensed):</p>

<pre><code>// testing/junit.out/nodeunit_basics.js.xml
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;testsuite name="nodeunit_basics.js"
         errors="0"
         failures="0"
         tests="2"&gt;
  &lt;testcase name="Test 1"&gt;
  &lt;/testcase&gt;
  &lt;testcase name="Test 2"&gt;
  &lt;/testcase&gt;
&lt;/testsuite&gt;</code></pre>

<p>This is great, but in a real-world development environment, you may be asked to write reports with a specific format, wording, or links (in html) to files with failing test cases.  Luckily, nodeunit allows us to customize this output.</p>

<h3 id="nodeunit_Custom_reporters">Nodeunit Custom reporters</h3>

<p>To write a custom reporter for nodeunit, first decide how you'd like nodeunit to report information about your tests.  As a simple example, let's take a look at a different take on the <a href="https://github.com/caolan/nodeunit/blob/master/lib/reporters/minimal.js">minimal</a> reporter.</p>

<p>Here are the modifications I'd like to see:</p>

<ul><li>Show the start time of the test</li><li>Show the filename as bold/green</li><li>Add <em>[PASS]</em> or <em>[FAIL]</em> after the <em>✔</em> or <em>✖</em></li><li>Prefix a test case with a '|'</li></ul>

<p>These may seem like contrived requirements.  But, what if my manager wants me to parse textual output for <em>[FAIL]</em> and, for whatever reason, it has to say <em>[FAIL]</em>?  </p>

<p>The modifications to the <em>minimal</em> reporter are too spread out to include inline here, so be sure to check out the file at <em>./src/testing/reporterse/example.js</em>.</p>

<p>Here is the slightly modified minimal output, meeting all of the requirements.</p>

<pre><code>$ cd src/testing &amp;&amp; nodeunit --reporter reporters/example.js nodeunit_basics.js 
Tests started: Tue Mar 22 2011 21:24:42 GMT-0700 (PDT)
nodeunit_basics.js: 

✔ [PASS] | Test 1
✖ [FAIL] | Test 2


AssertionError: false == true
    at Object.ok (/usr/local/lib/node/.npm/nodeunit/0.5.1/package/lib/types.js:81:39)
    at /home/jim/projects/masteringnode/src/testing/nodeunit_basics.js:10:14
    at Object.runTest (/usr/local/lib/node/.npm/nodeunit/0.5.1/package/lib/core.js:54:9)
    at /usr/local/lib/node/.npm/nodeunit/0.5.1/package/lib/core.js:90:21
    at /usr/local/lib/node/.npm/nodeunit/0.5.1/package/deps/async.js:508:13
    at /usr/local/lib/node/.npm/nodeunit/0.5.1/package/deps/async.js:118:25
    at /usr/local/lib/node/.npm/nodeunit/0.5.1/package/deps/async.js:129:25
    at /usr/local/lib/node/.npm/nodeunit/0.5.1/package/deps/async.js:510:17
    at Array.&lt;anonymous&gt; (/usr/local/lib/node/.npm/nodeunit/0.5.1/package/lib/types.js:144:17)
    at EventEmitter._tickCallback (node.js:108:26)


FAILURES: 1/3 assertions failed (9ms)</code></pre>

<p>These were small modifications, but following through the <a href="https://github.com/caolan/nodeunit/tree/master/lib/reporters">reporters included in nodeunit</a>, it will be easy to output test reports to your desired format.</p>

<h3 id="nodeunit_Mocks_and_Stubs">Nodeunit Mocks and Stubs</h3>

<p>  ...</p>

<h2 id="expresso">Expresso</h2>

<p>  ...</p>

<h2 id="vows">Vows</h2>

<p>  ...</p>

<h2 id="fixtures">Fixtures</h2>

<p>  ...</p>

<h1>Deployment</h1>

<p>  ...</p>

  </div>
  <script type="text/javascript" src="assets/sh_main.js"></script>
  <script type="text/javascript" src="assets/sh_javascript.min.js"></script>
  <script type="text/javascript">
	sh_highlightDocument(undefined, 'javascript', 'tt');
	sh_highlightDocument(undefined, 'javascript', 'code');
	sh_highlightDocument(undefined, 'javascript', 'pre');
  </script>
</body>
</html>
